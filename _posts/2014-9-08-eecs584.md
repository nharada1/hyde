---
layout: post
title: Paper Review - Self-selecting, Self-tuning, Incrementally Optimized Indexes 
category: eecs584
---

Our first truly modern technical paper, Graefe and Kuno's 2010 publication on adaptive indexes provides an efficient technique for automatic index generation and maintenance. 

As modern databases continue to grow to massive scales, access becomes more and more time consuming. Even an O(n) search complexity afforded by a simple scan is too slow when a table can contain millions of entries. Data structures known as indexes can solve this problem by creating a second structure for each column that allows faster access, for example a B-tree. This speed comes at an expense however - the index must be constructed for each column and may occasionally need to be optimized. 

Solutions exist to automatically reindex columns or monitor performance, but this requires a large operation whenever one of these reindexes is deemed necessary. Additionally, many of these tools require a highly trained and potentially expensive database administrator for the system. A proposed solution is to build the index on the fly, creating and improving index structure based on access to that column. This paper builds on previous work, a technique known as "Database Cracking", but instead of partitioning at each query the algorithm performs a merge step. Database cracking allows for an adaptive index, but is limiting in cases where the entire database index will not fit into local memory. Adaptive filtering is specifically targeted towards architectures where the index resides of disk, as is the case for extremely large databases.

Adaptive merging starts by creating sorted partitions from the raw data, sorted via quicksort and represented by a partitioned B-tree. The partition size is determined by the amount of physical memory available. Then incoming query ranges search each (sorted) partition and combine all results into a new "merge" partition. Additional queries select more data from the partitions and are merged into the final partition. Eventually all data will be contained in this final partition and the result will be a fully optimized index structure. Because the underlying data structure is the well-studied B-tree, traditional locking and logging structures can be used. Updates such as inserts and deletions can proceed traditionally or using optimized algorithms for small transactions.

Performance compared to database cracking appears good, and the algorithm is especially useful in its primary use case which is for large, block access disk devices. The overhead of primary partition creation is heavy for adaptive indexing, but if the quicksort operation can fit on primary memory, the resulting structure is very efficient compared to its partition-based sibling. Unlike database cracking, adaptive indexing's performance varies based on query range size - smaller query ranges are much less efficient. For systems where stability is important, cracking may be a better option. I would have also liked to see the tests performed on other types of data: the tests in the paper were done with permutations of consecutive integers. It would have been good to see, for example, performance on a database with many similar values or low cardinality.
