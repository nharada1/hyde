---
layout: post
title: 'Paper Review - C-Store: A Column-oriented DBMS'
category: eecs584
---
In what seems to be a common trend, this paper introduces yet another radical database architecture reimagining, again spearheaded by the prolific Michael Stonebraker. C-Store is a shared nothing column oriented database, designed for OLAP workloads with a focus on high read throughput and low read latency. This is in contrast to traditional DBMSs which are instead optimized for write efficiency. Written in 2005, this paper borrows heavily from other ideas in the database space, but is the first design to present a comprehensive architecture for a column store system that leverages modern computational systems such as shared nothing designs.

The core of C-store is the use of a column oriented data model, which eschews traditional row indexing in order to provide better read access in cases where a user is accessing a small subset of columns over a large quantity of tuples. C-Store accomplishes this by using projections, which are sorted subsets of attributes of a table. The database may contain any number of projections, but each column in must be present in at least one. By using column based projections, C-Store offers faster read performance for queries that read data mainly from columns, as many ad-hoc queries tend to do in analytic processing. For example, it's more likely for a client to request the first names of all clients than it is to request a client by name when doing data analysis. The paper gives an overview of other parts of the system, including a look at the snapshot isolation supported by the DBMS and the performance enhancements such as column compression and column-oriented optimizers and executors. Components of interest are the hybrid architecture for reading and writing, which consists of two separate storage utilities - one for reading and one for writing. The other interesting discussion is that of k-safety and the implementation of a shared nothing architecture. The paper ends with performance analysis (which is eye opening if taken at face value) as well as a look at systems that inspired C-Store.

### Strengths:
C-Store's use of column based projections offers an innovative solution to column based storage. While offering the obvious advantages of fast read access of OLAP workloads, the key insight of these projections is the use of overlap to facilitate k-safety. Because each projection (which is in essence a restricted materialized view) contains data that is non-dependent on the other projections, a given column can be represented multiple ways. By doing this the database can contain redundant columns and allow K nodes to fail while staying operational. 

The use of read stores and write stores is another clever innovation. C-Store compromises between read performance and writability by offering a small column store for writes to take place in. This store can be thought of as a staging area, or buffer for writes. Stored in memory, this buffer is eventually written to the database. By offering only snapshot isolation, the potential for lock contention and isolation failure is reduced with this eventually consistent system. This hybrid is especially useful because the column store requires many operations to do small updates.

### Weaknesses:
As with many shared nothing systems, the problem of how to distribute redundant data across nodes is a hard one. Determining the physical layout in C-Store requires the database administrator to maintain K-safety while also keeping performance optimal. This is devastating for a real world system, and an automated tool would be required for this system to function in a real world scenario. Another glaring weakness is the inability to operate efficiently on workloads unforeseen by the installer. If there is a scenario where we must do a large write, we will be horribly inefficient. In the same way, executing and transactional processing workload will cause the system to slow dramatically.  
