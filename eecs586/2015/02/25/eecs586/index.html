<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      TITLE &middot; Notes
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-146052-15', 'getpoole.com');
    ga('send', 'pageview');
  </script>

  <!-- LaTeX Support -->
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Notes
        </a>
      </h1>
      <p class="lead">Class notes for Nate Harada</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>
      <a class="sidebar-nav-item" href="about">About</a>
      <a class="sidebar-nav-item" href="http://blog.nateharada.com">Blog</a>

      <p></p>
      
          <a class="sidebar-nav-item" href="/categories/eecs492">EECS492</a> 
      
          <a class="sidebar-nav-item" href="/categories/eecs598">EECS598</a> 
      
          <a class="sidebar-nav-item" href="/categories/eecs584">EECS584</a> 
      
          <a class="sidebar-nav-item" href="/categories/eecs545">EECS545</a> 
      
          <a class="sidebar-nav-item" href="/categories/eecs586">EECS586</a> 
      
          <a class="sidebar-nav-item" href="/categories/eecs583">EECS583</a> 
      

    </nav>

    <p>&copy; 2015. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">TITLE</h1>
  <span class="post-date">25 Feb 2015</span>
  <h2 id="homework-review">Homework Review</h2>
<p>We can do problem 3 in <script type="math/tex">\Theta(cn \log n)</script> time instead of <script type="math/tex">\Theta(cn^2)</script>. </p>

<h2 id="shortest-paths">Shortest paths</h2>
<p>We have a graph with weights on each edge (directed). Find the shortest path from u to v (sum of weights). Many variations of this problem:</p>

<ul>
  <li>Go from single source to single destination</li>
  <li>Single source to all destinations</li>
  <li>All sources to one destination</li>
  <li>All sources all destinations</li>
</ul>

<p>The middle two are the same problem. You’d expect single single to be easier but nobody has a better worst case for any of the first three. This is chapter 24/25.</p>

<p>The solution is a rooted tree where everyone points to their parent. This is similar to Prim’s algorithm. Prim’s algorithm picks the edge of minimal weight but this doesn’t work for us. For each vertex not in the tree, keep track of the shortest path to get to it so far. We instead pick the edge with the minimum distance to the endpoint. </p>

<script type="math/tex; mode=display"> d(u) = \min(d(u), d(v)+w(e)) </script>

<p>This is Dijkstra’s algorithm. Time complexity of Prim is the same as this one. Single shortest path is easy, but what if we want a parallel version of this.</p>

<p>All to all distance? We could repeat the algorithm over and over, but we’re going to throw away a ton of stuff by doing that. Make a weighted adjacency matrix W, if no edge weight is infinity. Interpret this as the shortest path using one edge. </p>

<script type="math/tex; mode=display"> W_2(i,j) = \min \{ \min\limits_{k=1..n}W(i,k) + W(k,j), W(i,j) \}</script>

<p>This is the shortest path of two or fewer steps. </p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/eecs583/2015/11/11/">
            Classic Optimization
            <small>11 Nov 2015</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/eecs583/2015/10/14/eecs583/">
            Pin Paper
            <small>14 Oct 2015</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/eecs583/2015/10/12/">
            Paper Reviews 1 and 2
            <small>12 Oct 2015</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

    </div>

  </body>
</html>
